<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vagrant RPS Health</title>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Emoji:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Metamorphous&display=swap">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>‚öî</text></svg>">
    
    <style>
		/* --- Globalne Style --- */
		body {
			font-family: 'Lexend', sans-serif, 'Noto Emoji', sans-serif; /* Domy≈õlna czcionka */
			background-color: gainsboro; /* Jasnoszare t≈Ço strony */
            padding: 2px;
            padding-top: 60px; /* Odstƒôp od g√≥ry, aby zrobiƒá miejsce na lepki nag≈Ç√≥wek */
		}

        /* --- Lepki Nag≈Ç√≥wek (g√≥rny pasek) --- */
        #stickyHeader {
            position: fixed; /* Trzyma siƒô g√≥ry ekranu */
            top: 0;
            left: 0;
            right: 0;
            display: flex; /* U≈ºywa flexbox do wyr√≥wnania */
            justify-content: space-between; /* Elementy na krawƒôdziach */
            align-items: center; /* Wyr√≥wnanie w pionie */
            padding: 10px;
            background-color: darkred; /* Ciemnoczerwone t≈Ço */
            color: oldlace; /* Kremowy kolor tekstu */
			box-shadow: 0 0 10px black; /* Cie≈Ñ pod nag≈Ç√≥wkiem */
            z-index: 1000; /* Zawsze na wierzchu */
			max-height: 20px;
        }
        #stickyHeader h1 {
            font-family: 'Metamorphous', serif; /* Specjalna czcionka dla tytu≈Çu */
            max-width: 200px;
            font-size: 16px; 
			text-shadow: 0 0 4px black; /* Cie≈Ñ tekstu dla czytelno≈õci */
            margin-left: auto;
			margin-right: auto;
            /* flex-grow: 1; */ /* Usuniƒôte - marginesy auto sƒÖ kluczem */
            text-align: center; /* Wy≈õrodkowanie tekstu */
            cursor: pointer; /* Kursor d≈Çoni (sugeruje klikalno≈õƒá) */
        }
        #rollModeToggleHeader {
            font-family: 'Lexend', sans-serif;
            font-size: 14px;
            font-weight: bold;
			width: 80px;
            background: transparent; /* Przezroczyste t≈Ço */
			text-shadow: 0 0 4px black;
            color: oldlace; 
            border: none;
            cursor: pointer;
            padding: 0 10px;
            position: absolute; /* Pozycjonowanie absolutne */
            right: 10px; /* Po prawej stronie */
            top: 50%; /* Na ≈õrodku wysoko≈õci */
            transform: translateY(-50%); /* Precyzyjne centrowanie w pionie */
        }
        
        /* --- Globalne Kontrolki (pod nag≈Ç√≥wkiem) --- */
        #globalControls {
            max-width: 410px; /* Maksymalna szeroko≈õƒá */
            margin: 0 auto 10px auto; /* Centrowanie i odstƒôp dolny */
            display: flex; 
            flex-direction: column; /* Uk≈Çad kolumnowy */
            gap: 8px; /* Odstƒôp miƒôdzy wierszami */
            padding: 10px;
            border: 4px solid slategray; /* Szara ramka */
            background-color: oldlace; /* Kremowe t≈Ço */
            border-radius: 5px; /* ZaokrƒÖglone rogi */
            font-size: 14px;
        }
        
        /* Wiersz kontrolek (flexbox) */
        .controls-row {
            display: flex;
            gap: 8px;
            width: 100%;
        }

        /* Ukryty input do wczytywania plik√≥w */
        .hidden-file-input { display: none; }

        /* Styl bazowy dla przycisk√≥w globalnych i etykiet */
        .global-button, 
        .global-select-label {
            font-family: 'Lexend', sans-serif;
			color: oldlace; 
			border: none;
			padding: 6px 10px; 
			border-radius: 4px;
            cursor: pointer;
            background-color: darkred; /* Ciemnoczerwone t≈Ço */
            transition: background-color 0.1s; /* P≈Çynne przej≈õcie koloru */
            font-size: 14px;
            text-align: center;
		}
        /* Efekt wci≈õniƒôcia przycisku */
        .global-button:active { background-color: orange; }
        
        /* Lista rozwijana z szablonami */
        #templateSelect {
            font-family: 'Lexend', sans-serif;
            font-size: 14px;
            padding: 5px 8px;
            border-radius: 4px;
            background-color: oldlace; 
            border: 1px solid slategray; 
            width: 100%; 
            box-sizing: border-box; /* Rozmiar wliczajƒÖcy ramkƒô */
        }

        /* Klasa dla przycisk√≥w, kt√≥re majƒÖ rosnƒÖƒá (np. LOAD, EXPORT) */
        .flex-button {
            flex-grow: 3; /* RosnƒÖ 3x szybciej ni≈º .flex-button-small */
            flex-basis: 0;
            font-family: 'Lexend', sans-serif;
        }
        
        /* Klasa dla ma≈Çych przycisk√≥w ikonowych (np. ‚ûï, üóë) */
        .flex-button-small {
            flex-grow: 1; 
            flex-basis: 0;
            font-family: 'Noto Emoji', sans-serif;
			color: oldlace;
            font-size: 16px;
        }
        
        /* Specjalny kolor dla przycisk√≥w Import/Export/Delete */
        .import-export-btn {
            background-color: slategray; 
            color: oldlace; /* Upewnienie siƒô, ≈ºe kolor dla IMPORT/EXPORT/üóëÔ∏è jest oldlace */
        }
        
        /* --- Style Kart Postaci --- */
        .card {
            max-width: 380px;
            margin: 10px auto;
            padding: 10px;
            /* Ramka i cie≈Ñ sƒÖ teraz ustawiane dynamicznie przez JS (style inline) */
            background-color: oldlace;  
            border-radius: 5px;
            position: relative;
        }
        /* Domy≈õlne warto≈õci CSS (fallback), nadpisane w JS */
        .card {
            border: 4px solid steelblue;
			box-shadow: 0 0 10px steelblue;
        }


        /* --- Nag≈Ç√≥wek Karty (Przyciski g√≥ra/d√≥≈Ç i nazwa) --- */
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px; 
        }

        /* Styl dla przycisk√≥w akcji (g√≥ra/d√≥≈Ç, zapisz/usu≈Ñ/itd.) */
        .top-action-button {
            font-family: 'Noto Emoji', sans-serif; /* Zapewnia Noto Emoji dla ikon */
            font-size: 16px; 
            background-color: transparent; /* Przezroczyste t≈Ço */
            color: slategray; /* Kolor ikony */
            border: none; 
            border-radius: 0; /* Usuniƒôto zaokrƒÖglenie */
            cursor: pointer;
            padding: 0; /* Usuniƒôto padding */
            transition: color 0.1s; /* P≈Çynne przej≈õcie kolor√≥w */
            flex-grow: 1; 
            flex-basis: 0;
        }
        /* Efekt wci≈õniƒôcia przycisk√≥w akcji */
        .top-action-button:active { 
            background-color: transparent; /* Utrzymaj przezroczysto≈õƒá */
            color: orange; /* Kolor klikniƒôcia */
        }
        /* Upewnienie siƒô, ≈ºe przyciski g√≥ra/d√≥≈Ç majƒÖ sw√≥j w≈Çasny padding, aby wy≈õrodkowaƒá je w nag≈Ç√≥wku */
        .card-buttons-left .top-action-button,
        .card-buttons-top .top-action-button {
            padding: 5px; 
        }

		/* --- Nazwa Postaci (Input/Display) --- */
        .input-name {
            flex-grow: 1; 
			font-family: 'Lexend', sans-serif;
            text-align: center;
            margin: 0 5px; 
            cursor: pointer; 
            transition: background-color 0.1s, color 0.1s; 
            border-radius: 5px; 
        }
        /* Input tekstowy (widoczny w trybie edycji) */
		.input-name input[type="text"] {
			border: 1px solid slategray; 
			font-family: 'Lexend', sans-serif;

			padding: 5px;
			width: 100%; 
			font-size: 18px;
            box-sizing: border-box;
		}
        /* Ukrycie inputu w trybie zablokowanym */
        .input-name.locked input[type="text"] { display: none; }
        
        /* Span wy≈õwietlajƒÖcy nazwƒô (widoczny w trybie zablokowanym) */
        .input-name .display-name {
            font-size: 18px;
            font-weight: bold;
            padding: 5px;
            display: none; /* Domy≈õlnie ukryty */
            cursor: inherit; /* Dziedziczy kursor z rodzica */
        }
        /* Pokazanie spana w trybie zablokowanym */
        .input-name.locked .display-name { 
            display: block; 
            cursor: pointer; 
        }
        /* Reset kursora, gdy edytujemy (tryb unlocked) */
        .input-name:not(.locked) {
            cursor: default; 
        }
        
        /* --- Kolory t≈Ça/tekstu dla wyniku rzutu --- */
        /* Pokazywane na .input-name, kolor dziedziczony przez .display-name */
        .input-name.roll-fail { background-color: transparent; color: darkred; }
        .input-name.roll-success { background-color: transparent; color: green; }
        .input-name.roll-crit-fail { background-color: black; color: oldlace; } 
        .input-name.roll-crit-success { background-color: orange; color: black; } 

        /* --- G≈Ç√≥wne Kontrolki (≈ªycie i Status) --- */
        .control-row-main {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            padding: 0 10px;
            gap: 4px; /* Odstƒôpy miƒôdzy przyciskami */
        }
        /* Przyciski modyfikujƒÖce (np. +/- Trauma/Wound) i statusy */
        .mod-button, .status-button {
            font-family: 'Noto Emoji', sans-serif; 
            background-color: darkred; 
            color: oldlace; 
            border: none;
            padding: 0; 
            border-radius: 50%; /* OkrƒÖg≈Çe */
            cursor: pointer;
            font-size: 16px; 
            width: 40px; /* Sta≈Ça szeroko≈õƒá */
            height: 40px; /* Sta≈Ça wysoko≈õƒá */
            display: inline-flex;
            justify-content: center;
            align-items: center;
            margin: 0 2px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Lekki cie≈Ñ */
            transition: background-color 0.1s;
        }
        /* Style dla aktywnych status√≥w */
        .status-button.active { background-color: red; box-shadow: 0 0 10px red; }
        .status-button.active.ice { background-color: dodgerblue; box-shadow: 0 0 10px dodgerblue; } 
        .status-button.active.poison { background-color: green; box-shadow: 0 0 10px green; } 
        
        /* Pomara≈Ñczowy efekt klikniƒôcia tylko dla przycisk√≥w modyfikujƒÖcych */
        .mod-button:active { background-color: orange; box-shadow: 0 0 10px orange; }
        
        /* --- Pasek ≈ªycia (Health Bar) --- */
        .health-bar-container {
            flex-grow: 1; /* Zajmuje dostƒôpnƒÖ przestrze≈Ñ */
            position: relative; /* Baza dla element√≥w absolutnych */
            height: 18px;
            background-color: darkred; /* T≈Ço paska (reprezentuje obecne ≈ºycie) */
            border: 2px solid black;
            overflow: hidden; /* Ukrywa to, co wystaje */
            margin: 0 10px;
            cursor: default; 
        }
        /* Wsp√≥lny styl dla pask√≥w obra≈ºe≈Ñ (Trauma i Wound) */
        .damage-bar { 
            position: absolute; 
            height: 100%; 
            top: 0; 
            right: 0; /* ZaczynajƒÖ od prawej */
            transition: width 0.3s ease; /* P≈Çynna animacja zmiany szeroko≈õci */
        }
        .trauma-wound-bar { background-color: orange; z-index: 1; } /* Pasek Traumy (pomara≈Ñczowy) */
        .wound-bar { background-color: oldlace; z-index: 2; } /* Pasek Rany (kremowy, na wierzchu) */
        
        /* Nak≈Çadka tekstowa na pasku ≈ºycia */
        .value-overlay {
            position: absolute;
            font-size: 16px;
            font-weight: bold;
            z-index: 3; /* Na samym wierzchu */
            pointer-events: none; /* Ignoruje klikniƒôcia */
            top: 50%;
            transform: translateY(-50%); /* Centrowanie w pionie */
            white-space: nowrap; /* Zapobiega ≈Çamaniu tekstu */
        }
        /* Wy≈õwietlanie obecnego ≈ºycia (po lewej) */
        .current-vitality-display { 
            left: 5px; 
            color: oldlace; 
            text-shadow: 0 0 3px black, 0 0 3px black; /* Cie≈Ñ dla czytelno≈õci */
        } 
        /* Wy≈õwietlanie warto≈õci Traumy (po prawej od Rany) */
        .trauma-value-display { 
            right: -4px; 
            color: black; 
            text-shadow: 0 0 3px oldlace, 0 0 3px oldlace; 
        } 
        /* Wy≈õwietlanie warto≈õci Rany (na prawej krawƒôdzi) */
        .wound-value-display { 
            right: -4px; 
            color: darkred; 
            text-shadow: 0 0 3px oldlace, 0 0 3px oldlace; 
        }
        
        /* --- Sekcja Atrybut√≥w (rozwijana) --- */
        .attribute-section {
            display: none; /* Domy≈õlnie ukryta */
            padding: 10px 0 0 0;
            border-top: 1px solid slategray; /* Linia oddzielajƒÖca */
            margin-top: 10px;
        }
        .attribute-row {
            display: flex;
            justify-content: space-between;
            flex-wrap: nowrap;
            margin-bottom: 5px;
            padding: 0 5px;
        }
        .attribute-item {
            display: flex;
            flex-direction: column; /* Uk≈Çad pionowy (Label, Warto≈õƒá/Input) */
            align-items: center;
            width: 19%; /* Szeroko≈õƒá, aby zmie≈õciƒá 5 w rzƒôdzie */
            gap: 2px; 
            font-size: 9px; /* Ma≈Ça czcionka etykiety */
            text-align: center;
        }
        .attribute-item label { font-weight: bold; line-height: 1.1; }
        
        /* Input (tryb edycji) i Span (tryb zablokowany) dla warto≈õci atrybutu */
        .attribute-item input[type="number"],
        .attribute-item .attribute-value {
            font-family: 'Lexend';
            padding: 5px 2px; 
            width: 100%;
            font-size: 14px; 
            font-weight: bold;
            text-align: center;
            box-sizing: border-box; 
            height: 40px; 
        }
        .attribute-item .attribute-value { 
            border: 0px solid slategray; /* Przezroczysta ramka dla zachowania rozmiaru */
			box-shadow: 0 0px 0px slategray; /* Lekki cie≈Ñ */
            border-radius: 3px;
            font-size: 18px; 
            display: flex; /* Do centrowania tekstu w pionie */
            justify-content: center;
            align-items: center;
        }
        
        /* Efekt klikniƒôcia dla klikalnych atrybut√≥w (do rzutu) */
        .attribute-value.rollable:active { 
            background-color: orange; 
            cursor: pointer; 
            border: 1px solid slategray; 
        } 
		.attribute-value.rollable:hover {
            cursor: pointer;
        } 
        /* Ukrywanie inputu w trybie zablokowanym */
        .attribute-item.locked input[type="number"] { display: none; }
        /* Ukrywanie spana w trybie edycji (unlocked) */
        .attribute-item:not(.locked) .attribute-value { display: none; }
        
        /* Kontener na przyciski akcji (Zapisz, Usu≈Ñ, Edytuj itp.) */
        .attribute-buttons {
             display: flex;
             /* justify-content: space-around; */ /* Usuniƒôte na rzecz gap */
             align-items: center; 
             margin-top: 10px;
             border-top: 1px solid slategray; 
             padding-top: 10px;
             gap: 5px; /* DODANO odstƒôp miƒôdzy przyciskami */
        }
        
        /* --- Dziennik Rzut√≥w (Roll Log) --- */
        #rollLogContainer {
            max-width: 410px;
            margin: 20px auto 10px auto;
            padding: 10px;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Lekki cie≈Ñ */
            border: 4px solid slategray; 
            background-color: oldlace; 
            border-radius: 5px;
        }
        #rollLogContainer h3 {
            margin-top: 0;
            font-size: 16px;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Lekki cie≈Ñ */
            border-bottom: 1px solid slategray; 
            padding-bottom: 5px;
        }
        #rollLog {
            max-height: 300px; /* Maksymalna wysoko≈õƒá, potem scroll */
            overflow-y: auto; /* W≈ÇƒÖcza scrollowanie w pionie */
            list-style: none; /* Bez kropek */
            padding: 0;
            margin: 0;
            font-size: 12px;
            
            /* --- Stylizowanie paska przewijania --- */
            scrollbar-color: gainsboro oldlace; /* Firefox */
            scrollbar-width: thin;
        }
        /* Pasek przewijania dla Webkit (Chrome, Safari, Edge) */
        #rollLog::-webkit-scrollbar {
            width: 8px;
        }
        #rollLog::-webkit-scrollbar-track {
            background: oldlace; /* T≈Ço paska */
        }
        #rollLog::-webkit-scrollbar-thumb {
            background-color: gainsboro; /* Uchwyt paska */
            border-radius: 4px;
        }
        #rollLog::-webkit-scrollbar-thumb:hover {
            background-color: red; /* Kolor uchwytu po najechaniu */
        }
        
        #rollLog li {
            padding: 3px 0;
            border-bottom: 1px dotted slategray; /* Linia oddzielajƒÖca wpisy */
        }
        /* Kolory dla wynik√≥w rzut√≥w w logu */
        .log-crit-fail { color: black; font-weight: bold; }
        .log-fail { color: darkred; }
        .log-success { color: green; } 
        .log-crit-success { color: orange; font-weight: bold; }
        
        /* --- Dolne Kontrolki (Heal All, Clear Scene) --- */
        #bottomControls {
            max-width: 430px;
            margin: 10px auto;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Lekki cie≈Ñ */
            display: grid;
            grid-template-columns: 1fr 1fr 1fr; /* Trzy r√≥wne kolumny */
            gap: 8px;
        }
        #bottomControls .global-button {
            background-color: slategray; /* Szare t≈Ço */
            font-size: 12px;
        }
        /* Stopka */
        #footer {
            max-width: 400px;
            margin: 15px auto 10px auto;
            text-align: center;
            font-size: 10px;
            color: slategray;
            font-family: 'Lexend', sans-serif;
        }
        
    </style>
</head>
<body>
    
    <div id="stickyHeader">
        <h1 onclick="showInfo()" title="Vagrant RPS Info">VAGRANT RPS</h1>
        <button id="rollModeToggleHeader" onclick="toggleRollMode()" title="Roll Mode Toggle">d12</button>
    </div>

    <div id="globalControls">
        <div class="controls-row">
            <select id="templateSelect" title="Select Template for 'NEW' (‚ûï) or 'Apply' (‚ú®)"></select>
        </div>
        
        <div class="controls-row">
            <button id="newCharButton" class="global-button flex-button-small" onclick="applyTemplateToNewCharacter()" title="New Character (using selected template)">‚ú®</button>
            
            <button class="global-button flex-button" onclick="document.getElementById('importFileAllHidden').click()" title="Load character(s): single (adds) or scene (replaces)">LOAD</button>
            <input type="file" id="importFileAllHidden" class="hidden-file-input" accept=".json" onchange="importAllCharacters(event)">
            
            <button class="global-button import-export-btn flex-button" onclick="document.getElementById('importFileTemplatesHidden').click()" title="Import Templates from a file">IMPORT</button>
            <input type="file" id="importFileTemplatesHidden" class="hidden-file-input" accept=".json" onchange="importTemplates(event)">

            <button class="global-button import-export-btn flex-button" onclick="exportCharacters()" title="Export all characters">EXPORT</button>
            
            <button id="deleteTemplateButton" class="global-button flex-button-small" onclick="deleteSelectedTemplate()" title="Delete selected user template">üóë</button>
        </div>
    </div>

    <div id="characterContainer">
        </div>

    <div id="bottomControls">
        <button class="global-button" onclick="healAll()" title="Heal all Trauma/Wounds">HEAL ALL</button>
        <button class="global-button" onclick="clearAll()" title="Delete all characters">CLEAR SCENE</button>
        <button class="global-button" onclick="resetPage()" title="Reset all data (characters and templates)">RESET PAGE</button>
    </div>


    <div id="rollLogContainer">
        <h3>üé≤ Roll Log</h3>
        <ul id="rollLog">
            </ul>
    </div>

    <div id="footer">
        Vagrant RPS by Genpiusz 2025, All rights reserved
    </div>

    <script>
        // --- ZMIENNE GLOBALNE I KONFIGURACJA ---
        const LOCAL_STORAGE_KEY = 'allCharacters'; // Klucz do zapisu postaci w localStorage
        const VAGRANT_TEMPLATES_KEY = 'vagrantTemplates'; // Klucz do zapisu szablon√≥w u≈ºytkownika
        const DEFAULT_VITALITY = 12; // Domy≈õlna Witalno≈õƒá
        const DEFAULT_TRAUMA = 0; // Domy≈õlna Trauma
        const DEFAULT_WOUND = 0; // Domy≈õlna Rana
        
        // Kolory obramowania karty do prze≈ÇƒÖczania
        const CARD_COLORS = ['slategray', 'dodgerblue', 'green', 'red'];
        
        // Domy≈õlne warto≈õci atrybut√≥w dla nowej, pustej postaci
        const DEFAULT_ATTRIBUTES = {
            perception: 0, strength: 0, dexterity: 0, agility: 0, armor: 0, 
            charisma: 0, potential: 0, stability: 0, reason: 0,
            editMode: 'locked' // Domy≈õlny tryb edycji
        };

        // Domy≈õlne szablony postaci, dostƒôpne na starcie
        const DEFAULT_TEMPLATES = {
            'New Character': {
                name: 'New Character', 
                vitality: 12,
                perception: 0, strength: 0, dexterity: 0, agility: 0, armor: 0, 
                charisma: 0, potential: 0, stability: 0, reason: 0,
            },
            'Knight': {
                name: 'Sir Reginald', vitality: 15, perception: 1, strength: 3, dexterity: 1, agility: 2, 
                armor: 4, charisma: 1, potential: 0, stability: 3, reason: 1
            },
            'Bandit': {
                name: 'Shifty Pete', vitality: 12, perception: 2, strength: 2, dexterity: 2, agility: 3, 
                armor: 1, charisma: -1, potential: 0, stability: 1, reason: 0
            },
            'Villager': {
                name: 'Simple John', vitality: 10, perception: 1, strength: 1, dexterity: 0, agility: 0, 
                armor: 0, charisma: 1, potential: 0, stability: 2, reason: 1
            },
            'Merchant': {
                name: 'Trader Bob', vitality: 10, perception: 2, strength: 0, dexterity: 1, agility: 0, 
                armor: 0, charisma: 3, potential: 0, stability: 2, reason: 2
            },
            'Cleric': {
                name: 'Brother Michael', vitality: 13, perception: 1, strength: 1, dexterity: 0, agility: 0, 
                armor: 2, charisma: 2, potential: 1, stability: 3, reason: 3
            },
            'Servant': {
                name: 'Scrub Jane', vitality: 11, perception: 0, strength: 0, dexterity: 1, agility: 1, 
                armor: 0, charisma: 0, potential: 0, stability: 2, reason: 0
            },
            'Mage': {
                name: 'Wizard Tim', vitality: 9, perception: 2, strength: -1, dexterity: 1, agility: 0, 
                armor: 0, charisma: 1, potential: 3, stability: 0, reason: 4
            }
        };

        // Obiekt przechowujƒÖcy po≈ÇƒÖczone szablony (domy≈õlne + u≈ºytkownika)
        let TEMPLATES = {};

        // G≈Ç√≥wna tablica przechowujƒÖca wszystkie postacie na scenie
        let allCharacters = [];
        // Globalny tryb rzutu ko≈õciƒÖ
        let rollMode = 'd12'; // 'd12', '2d12A' (Advantage), '2d12D' (Disadvantage)

        // --- RDZE≈É LOGIKI RZUT√ìW KO≈öCIƒÑ ---

        /**
         * Generuje rzuty ko≈õciƒÖ w zale≈ºno≈õci od globalnego trybu (rollMode).
         * @returns {object} Obiekt zawierajƒÖcy rzuty, wybrany rzut i tekst do wy≈õwietlenia.
         */
        function getDiceRolls() {
            const d1 = Math.floor(Math.random() * 12) + 1; // Pierwszy rzut k12
            const d2 = Math.floor(Math.random() * 12) + 1; // Drugi rzut k12
            
            if (rollMode === 'd12') {
                // Tryb standardowy: 1k12
                return { rolls: [d1], selectedRoll: d1, displayRolls: `${d1}` };
            } else if (rollMode === '2d12A') {
                // Tryb Advantage: 2k12, wybierz wy≈ºszy
                const selected = Math.max(d1, d2);
                return { rolls: [d1, d2], selectedRoll: selected, displayRolls: `${d1}/${d2}A` }; // Dodano 'A'
            } else if (rollMode === '2d12D') {
                // Tryb Disadvantage: 2k12, wybierz ni≈ºszy
                const selected = Math.min(d1, d2);
                return { rolls: [d1, d2], selectedRoll: selected, displayRolls: `${d1}/${d2}D` }; // Dodano 'D'
            }
        }
        
        /**
         * Oblicza wynik rzutu, okre≈õla sukces/pora≈ºkƒô i klasy CSS.
         * @param {number[]} rolls - Tablica rzut√≥w (np. [1, 5]).
         * @param {number} selectedRoll - Rzut wybrany (np. 5).
         * @param {number} attributeValue - Modyfikator z atrybutu.
         * @returns {object} Obiekt z wynikiem, klasami CSS i znakiem (+/-).
         */
        function getRollResult(rolls, selectedRoll, attributeValue) {
            const result = selectedRoll + attributeValue; // Suma rzutu i atrybutu
            let logClass = ''; // Klasa CSS dla logu
            let resultClass = ''; // Klasa CSS dla nazwy postaci
            
            let isCritSuccess = selectedRoll === 12; // Czy krytyczny sukces?
            let isCritFail = selectedRoll === 1; // Czy krytyczna pora≈ºka?

            // Specjalne zasady dla Advantage/Disadvantage
            if (rollMode === '2d12A' && rolls.includes(1)) {
                isCritFail = false; // MajƒÖc A, 1 nie jest auto-pora≈ºkƒÖ
            }
            if (rollMode === '2d12D' && rolls.includes(12)) {
                isCritSuccess = false; // MajƒÖc D, 12 nie jest auto-sukcesem
            }

            // Przypisanie klas na podstawie wyniku
            if (isCritFail) {
                logClass = 'log-crit-fail';
                resultClass = 'roll-crit-fail'; 
            } else if (isCritSuccess) {
                logClass = 'log-crit-success';
                resultClass = 'roll-crit-success';
            } else if (result >= 8) {
                // Sukces (wynik 8+)
                logClass = 'log-success';
                resultClass = 'roll-success'; 
            } else { 
                // Pora≈ºka (wynik < 8)
                logClass = 'log-fail';
                resultClass = 'roll-fail'; 
            }

            const sign = attributeValue >= 0 ? '+' : ''; // Znak plus dla dodatnich atrybut√≥w
            
            return { result, logClass, resultClass, sign };
        }
        
        /**
         * Wykonuje rzut na atrybut dla konkretnej postaci.
         * @param {number} index - Indeks postaci w tablicy allCharacters.
         * @param {string} attributeName - Nazwa atrybutu (np. 'strength').
         */
        function rollDice(index, attributeName) {
            let char = allCharacters[index];
            if (!char) return;

            // Nie mo≈ºna rzucaƒá na Witalno≈õƒá ani Pancerz
            if (attributeName === 'vitality' || attributeName === 'armor') { return; }

            const attributeValue = parseInt(char[attributeName]) || 0;
            const nameContainer = document.getElementById(`inputNameContainer-${index}`);
            const displayNameSpan = document.getElementById(`displayName-${index}`);
            const originalName = char.name;
            
            // Pobranie rzutu i wyniku
            const { rolls, selectedRoll, displayRolls } = getDiceRolls();
            const { result, logClass, resultClass, sign } = getRollResult(rolls, selectedRoll, attributeValue);
            
            // Formatowanie tekstu dla logu (usuwamy A/D z displayRolls, bo jest ju≈º w logClass)
            let displayRollsForFormat = displayRolls.replace('A', '').replace('D', '');
            
            // Pobranie etykiety atrybutu (np. "STRENGTH")
            const attributeSpan = document.getElementById(`${attributeName}ValueDisplay-${index}`);
            const labelElement = attributeSpan.closest('.attribute-item').querySelector('label');
            const attributeLabel = labelElement.title.split('(')[0].trim().toUpperCase();
            
            // Wiadomo≈õƒá do wy≈õwietlenia na karcie postaci
            // U≈ºywamy pe≈Çnego rzutu (displayRolls) z A/D (np. '5/8A')
            const calculation = `${displayRolls}${sign}${attributeValue}`;
            const rollMessage = `${attributeLabel}: ${result} (${calculation})`; 

            // Reset klas i wy≈õwietlanie wyniku
            nameContainer.classList.remove('roll-fail', 'roll-success', 'roll-crit-fail', 'roll-crit-success');
            
            displayNameSpan.textContent = rollMessage;
            nameContainer.classList.add(resultClass); // Dodanie klasy (np. .roll-success)
            displayNameSpan.style.textShadow = ''; // Reset cienia tekstu

            // Dodanie wpisu do logu
            const logEntry = document.createElement('li');
            logEntry.textContent = `${originalName} - ${attributeLabel}: ${result} (${displayRolls.replace('/', '/')}${sign}${attributeValue})`; 
            logEntry.classList.add(logClass);
            
            const rollLog = document.getElementById('rollLog');
            rollLog.prepend(logEntry); // Dodanie na g√≥rze logu
            
            // Timer resetujƒÖcy wy≈õwietlanie wyniku rzutu
            setTimeout(() => {
                if (displayNameSpan.textContent === rollMessage) {
                     displayNameSpan.textContent = originalName; // Powr√≥t do nazwy
                     nameContainer.classList.remove('roll-fail', 'roll-success', 'roll-crit-fail', 'roll-crit-success');
                }
            }, 5000); // Po 5 sekundach
        }

        /**
         * Wykonuje "p≈Çaski" rzut (bez atrybutu) dla postaci.
         * @param {number} index - Indeks postaci.
         */
        function flatRoll(index) {
            let char = allCharacters[index];
            if (!char) return;

            const nameContainer = document.getElementById(`inputNameContainer-${index}`);
            const displayNameSpan = document.getElementById(`displayName-${index}`);
            const originalName = char.name;

            // Rzut i wynik (bez atrybutu)
            const { rolls, selectedRoll, displayRolls } = getDiceRolls();
            const { result, logClass, resultClass } = getRollResult(rolls, selectedRoll, 0); // Atrybut = 0
            
            const rollTypePrefix = rollMode.toUpperCase().replace('2D12', 'FLAT'); 
            // U≈ºywamy pe≈Çnego rzutu (displayRolls) z A/D (np. '5/8A')
            const rollMessage = `${rollTypePrefix}: ${result} (${displayRolls})`; 

            // Wy≈õwietlanie wyniku
            nameContainer.classList.remove('roll-fail', 'roll-success', 'roll-crit-fail', 'roll-crit-success');
            displayNameSpan.textContent = rollMessage;
            nameContainer.classList.add(resultClass);
            displayNameSpan.style.textShadow = ''; // Reset cienia

            // Timer resetujƒÖcy
            setTimeout(() => {
                if (displayNameSpan.textContent === rollMessage) {
                     displayNameSpan.textContent = originalName;
                     nameContainer.classList.remove('roll-fail', 'roll-success', 'roll-crit-fail', 'roll-crit-success');
                }
            }, 5000); 

            // Dodanie do logu (usuwamy A/D z displayRolls dla logu, bo ju≈º jest w rollTypePrefix)
            const logEntry = document.createElement('li');
            const displayRollsForLog = displayRolls.replace('A', '').replace('D', ''); // Log bez A/D
            logEntry.textContent = `${char.name} - ${rollTypePrefix}: ${result} (${displayRollsForLog})`;
            logEntry.classList.add(logClass);
            
            const rollLog = document.getElementById('rollLog');
            rollLog.prepend(logEntry);
        }

        /**
         * Prze≈ÇƒÖcza globalny tryb rzutu (d12 -> 2d12A -> 2d12D -> d12).
         */
        function toggleRollMode() {
            if (rollMode === 'd12') {
                rollMode = '2d12A';
            } else if (rollMode === '2d12A') {
                rollMode = '2d12D';
            } else {
                rollMode = 'd12';
            }
            
            // Aktualizacja tekstu na przycisku w nag≈Ç√≥wku
            document.querySelectorAll('#rollModeToggleHeader').forEach(el => {
                el.textContent = rollMode.replace('2d12', 'd12'); // Wy≈õwietlanie "d12A" lub "d12D"
            });
        }
        
        /**
         * Zaznacza ca≈ÇƒÖ zawarto≈õƒá elementu input.
         * @param {HTMLElement} inputElement - Element input do zaznaczenia.
         */
        function selectContent(inputElement) {
            inputElement.select();
        }


        // --- RDZE≈É LOGIKI POSTACI ---
        
        /**
         * Aktualizuje wizualny pasek ≈ºycia (health bar) dla postaci.
         * @param {number} charIndex - Indeks postaci.
         */
        function updateHealthBar(charIndex) {
            let char = allCharacters[charIndex];
            if (!char) return;

            // Walidacja warto≈õci (Witalno≈õƒá min 1, Trauma/Rana min 0)
            const vitality = Math.max(parseInt(char.vitality) || 0, 1);
            let trauma = parseInt(char.trauma) || 0;
            let wound = parseInt(char.wound) || 0;
            
            trauma = Math.max(0, trauma);
            wound = Math.max(0, wound);
            
            // Logika zapobiegania przekroczeniu Witalno≈õci przez obra≈ºenia
            const totalDamage = trauma + wound;
            if (totalDamage > vitality) {
                const excess = totalDamage - vitality; // Ile obra≈ºe≈Ñ jest za du≈ºo
                char.wound = Math.max(0, wound - excess); // Redukuj Rany
                const newTotalDamage = char.trauma + char.wound;
                if (newTotalDamage > vitality) {
                    // Je≈õli Trauma sama przekracza, zredukuj Ranƒô do 0 (Trauma ma priorytet)
                    char.wound = vitality - char.trauma;
                }
            }
            
            trauma = char.trauma;
            wound = char.wound;

            // Obliczenia procentowe dla pask√≥w
            const traumaWoundPercentage = ((trauma + wound) / vitality) * 100;
            const woundPercentage = (wound / vitality) * 100;
            const currentVitality = vitality - (trauma + wound); // Obecne ≈ºycie

            // Pobranie element√≥w DOM
            const traumaWoundBar = document.getElementById(`traumaWoundBar-${charIndex}`);
            const woundBar = document.getElementById(`woundBar-${charIndex}`);
            const traumaDisplay = document.getElementById(`traumaValueDisplay-${charIndex}`);
            const woundDisplay = document.getElementById(`woundValueDisplay-${charIndex}`);
            const currentVitalityDisplay = document.getElementById(`currentVitalityDisplay-${charIndex}`);
            
            if (!traumaWoundBar) return; // Zabezpieczenie (je≈õli karta nie istnieje)

            // Ustawienie szeroko≈õci pask√≥w
            traumaWoundBar.style.width = traumaWoundPercentage + '%';
            woundBar.style.width = woundPercentage + '%';
            
            // Wy≈õwietlanie obecnej Witalno≈õci (po lewej)
            if (currentVitality > 0) {
                currentVitalityDisplay.style.display = 'block';
                currentVitalityDisplay.textContent = currentVitality;
            } else {
                currentVitalityDisplay.style.display = 'none'; // Ukryj, je≈õli 0 lub mniej
            }

            // Wy≈õwietlanie warto≈õci Traumy (miƒôdzy paskiem Witalno≈õci a Ran)
            if (trauma > 0) {
                traumaDisplay.style.display = 'block';
                traumaDisplay.textContent = ` ${trauma} `; 
                const woundRightPercentage = woundPercentage;
                traumaDisplay.style.right = `${woundRightPercentage}%`; // Pozycjonowanie
                traumaDisplay.style.transform = `translate(-100%, -50%)`; 
            } else {
                traumaDisplay.style.display = 'none';
            }
            
            // Wy≈õwietlanie warto≈õci Rany (ikona kropli, po prawej)
             if (wound > 0) {
                woundDisplay.style.display = 'block';
                woundDisplay.textContent = wound === 1 ? 'ü©∏' : `${wound}ü©∏`;
            } else {
                woundDisplay.style.display = 'none';
            }
            
            saveAllCharacters(); // Zapis po ka≈ºdej zmianie
        }

        /**
         * Zmienia warto≈õƒá Traumy lub Rany (obs≈Çuguje przyciski +/-).
         * @param {number} index - Indeks postaci.
         * @param {string} id - 'trauma' lub 'wound'.
         * @param {number} delta - Zmiana (+1 lub -1).
         */
        function changeValue(index, id, delta) {
            let char = allCharacters[index];
            if (!char) return;
            
            const vitality = parseInt(char.vitality);
            let trauma = parseInt(char.trauma);
            let wound = parseInt(char.wound);
            
            if (id === 'wound') {
                // Zmiana Rany
                let newWound = Math.max(0, wound + delta);
                
                if (delta > 0) { // Je≈õli dodajemy Ranƒô
                    let totalDamage = newWound + trauma;
                    if (totalDamage > vitality) {
                        // Je≈õli przekracza, redukujemy Traumƒô, aby zmie≈õciƒá Ranƒô
                        const excess = totalDamage - vitality;
                        trauma = Math.max(0, trauma - excess);
                        newWound = Math.min(newWound, vitality - trauma);
                    }
                }
                char.trauma = Math.min(vitality, trauma);
                char.wound = Math.min(vitality - char.trauma, newWound); 

            } else if (id === 'trauma') {
                // Zmiana Traumy
                let newTrauma = Math.max(0, trauma + delta);
                
                if (delta > 0) { // Je≈õli dodajemy Traumƒô
                    const currentTotalDamage = trauma + wound;
                    
                    if (currentTotalDamage >= vitality) {
                        // Je≈õli ju≈º mamy max obra≈ºe≈Ñ, nie dodajemy wiƒôcej Traumy
                        if (newTrauma > trauma) { 
                            newTrauma = trauma; 
                        }
                    } else {
                        // Je≈õli jest miejsce, ale przekroczy...
                        let totalDamage = newTrauma + wound;
                        if (totalDamage > vitality) {
                            // Redukujemy Rany, aby zmie≈õciƒá Traumƒô
                            const excess = totalDamage - vitality;
                            wound = Math.max(0, wound - excess);
                            newTrauma = vitality - wound; // Trauma wype≈Çnia resztƒô
                        }
                    }
                }
                
                char.trauma = Math.min(vitality, newTrauma);
                char.wound = Math.min(vitality - char.trauma, wound);
            }
            
            // Ostateczna walidacja, aby suma nie przekroczy≈Ça Witalno≈õci
            const currentTotalDamage = char.trauma + char.wound;
            if (currentTotalDamage > vitality) {
                char.wound = Math.max(0, char.wound - (currentTotalDamage - vitality));
            }

            updateHealthBar(index); // Aktualizacja paska
        }
        
        /**
         * Aktualizuje nazwƒô postaci po wpisaniu w input.
         * @param {number} index - Indeks postaci.
         * @param {HTMLElement} inputElement - Element input.
         */
        function updateName(index, inputElement) {
            let char = allCharacters[index];
            if (char) {
                char.name = inputElement.value;
                document.getElementById(`displayName-${index}`).textContent = char.name; // Aktualizacja spana
                saveAllCharacters();
            }
        }

        /**
         * Aktualizuje atrybut postaci po wpisaniu w input.
         * @param {number} index - Indeks postaci.
         * @param {string} attribute - Nazwa atrybutu.
         * @param {HTMLElement} inputElement - Element input.
         */
        function updateAttribute(index, attribute, inputElement) {
            let char = allCharacters[index];
            if (char) {
                char[attribute] = parseInt(inputElement.value) || 0;
                
                // Aktualizacja spana wy≈õwietlajƒÖcego (w trybie locked)
                const attrSpan = document.getElementById(`${attribute}ValueDisplay-${index}`);
                if (attrSpan) {
                    const isSigned = (attribute !== 'vitality' && attribute !== 'armor');
                    const sign = isSigned && char[attribute] >= 0 ? '+' : ''; // Dodanie plusa
                    
                    attrSpan.textContent = `${sign}${char[attribute]}`;
                }

                if (attribute === 'vitality') {
                    updateHealthBar(index); // Przeliczenie paska ≈ºycia
                }

                saveAllCharacters();
            }
        }
        
        /**
         * Prze≈ÇƒÖcza status (Ogie≈Ñ, L√≥d, Trucizna).
         * @param {number} index - Indeks postaci.
         * @param {string} status - Nazwa statusu ('fire', 'ice', 'poison').
         */
        function toggleStatus(index, status) {
            let char = allCharacters[index];
            if (char) {
                const statusKey = `status${status.charAt(0).toUpperCase() + status.slice(1)}`; // Np. 'statusFire'
                char[statusKey] = char[statusKey] === 'on' ? 'off' : 'on'; // Prze≈ÇƒÖczenie
                saveAllCharacters();
                
                // Aktualizacja wyglƒÖdu przycisku
                const btn = document.getElementById(`btn-${status}-${index}`);
                btn.classList.remove('fire', 'ice', 'poison', 'active');
                
                if (char[statusKey] === 'on') {
                    btn.classList.add('active', status); // Dodanie klas aktywnych
                }
            }
        }
        
        /**
         * Przesuwa kartƒô postaci w g√≥rƒô lub w d√≥≈Ç.
         * @param {number} index - Obecny indeks postaci.
         * @param {number} direction - Kierunek (-1 = g√≥ra, +1 = d√≥≈Ç).
         */
        function moveCharacter(index, direction) {
            const newIndex = index + direction;
            // Sprawdzenie, czy nowy indeks jest w granicach tablicy
            if (newIndex >= 0 && newIndex < allCharacters.length) {
                // Zamiana miejscami w tablicy
                [allCharacters[index], allCharacters[newIndex]] = [allCharacters[newIndex], allCharacters[index]];
                saveAllCharacters();
                renderAllCharacters(); // Przerenderowanie wszystkich kart
            }
        }
        
        /**
         * Rozwija lub zwija sekcjƒô atrybut√≥w.
         * @param {number} index - Indeks postaci.
         */
        function toggleAttributeSection(index) {
            let char = allCharacters[index];
            if (!char || char.editMode !== 'locked') return; // Dzia≈Ça tylko w trybie locked

            const section = document.getElementById(`attributeSection-${index}`);
            const isVisible = section.style.display === 'block';

            if (isVisible) {
                // Je≈õli zamykamy, automatycznie blokujemy edycjƒô
                toggleEditMode(index, 'locked'); 
                section.style.display = 'none';
            } else {
                section.style.display = 'block';
            }
        }
        
        /**
         * Prze≈ÇƒÖcza tryb edycji (zablokowany/odblokowany).
         * @param {number} index - Indeks postaci.
         * @param {string} [mode='toggle'] - 'toggle', 'locked', lub 'unlocked'.
         */
        function toggleEditMode(index, mode = 'toggle') {
            let char = allCharacters[index];
            let newMode = char.editMode;

            // Ustalenie nowego trybu
            if (mode === 'toggle') {
                newMode = char.editMode === 'locked' ? 'unlocked' : 'locked';
            } else if (mode === 'locked' || mode === 'unlocked') {
                newMode = mode;
            }
            
            char.editMode = newMode;
            saveAllCharacters();

            // Aktualizacja element√≥w DOM
            const lockButton = document.getElementById(`editModeToggle-${index}`);
            const nameContainer = document.getElementById(`inputNameContainer-${index}`);
            const attributeInputs = document.querySelectorAll(`#attributeSection-${index} .attribute-item`);
            
            if (lockButton) { 
                lockButton.textContent = newMode === 'locked' ? 'üîí' : 'üîì'; // Zmiana ikony
            }
            
            // Dodanie/usuniƒôcie klas .locked
            if (newMode === 'locked') {
                nameContainer.classList.add('locked');
                attributeInputs.forEach(item => item.classList.add('locked'));
            } else {
                nameContainer.classList.remove('locked');
                attributeInputs.forEach(item => item.classList.remove('locked'));
            }
        }
        
        /**
         * Zmienia kolor obramowania karty (cyklicznie).
         * @param {number} index - Indeks postaci.
         */
        function toggleCardColor(index) {
            let char = allCharacters[index];
            if (!char) return;

            // Pobranie obecnego indeksu koloru (lub 0, je≈õli nie istnieje)
            let currentIndex = parseInt(char.cardColorIndex) || 0;
            
            // Przej≈õcie do nastƒôpnego koloru
            currentIndex = (currentIndex + 1) % CARD_COLORS.length;
            char.cardColorIndex = currentIndex;
            
            const newColor = CARD_COLORS[currentIndex];
            const cardElement = document.querySelector(`.card[data-index="${index}"]`);
            
            // Zastosowanie nowego koloru (border i shadow)
            if (cardElement) {
                cardElement.style.borderColor = newColor;
                cardElement.style.boxShadow = `0 0 10px ${newColor}`;
            }

            saveAllCharacters();
        }


        // --- LOGIKA SZABLON√ìW (TEMPLATES) ---
        
        /**
         * ≈Åaduje domy≈õlne szablony i ≈ÇƒÖczy je z szablonami zapisanymi w localStorage.
         */
        function loadAndMergeTemplates() {
            // G≈Çƒôboka kopia domy≈õlnych szablon√≥w
            TEMPLATES = JSON.parse(JSON.stringify(DEFAULT_TEMPLATES));
            
            try {
                // Pr√≥ba wczytania szablon√≥w u≈ºytkownika
                const savedTemplates = JSON.parse(localStorage.getItem(VAGRANT_TEMPLATES_KEY));
                if (savedTemplates) {
                    // Po≈ÇƒÖczenie/nadpisanie domy≈õlnych przez szablony u≈ºytkownika
                    Object.assign(TEMPLATES, savedTemplates);
                }
            } catch (e) {
                console.error("Error loading templates from localStorage:", e);
                // W razie b≈Çƒôdu, wracamy tylko do domy≈õlnych
                TEMPLATES = JSON.parse(JSON.stringify(DEFAULT_TEMPLATES));
            }
        }

        /**
         * Wype≈Çnia listƒô rozwijanƒÖ (select) dostƒôpnymi szablonami.
         */
        function populateTemplateSelect() {
            const select = document.getElementById('templateSelect');
            if (!select) return;
            
            select.innerHTML = ''; // Wyczy≈õƒá listƒô
            
            // Upewnij siƒô, ≈ºe "New Character" jest zawsze na g√≥rze
            const defaultTemplateName = 'New Character';
            if (TEMPLATES[defaultTemplateName]) {
                const option = document.createElement('option');
                option.value = defaultTemplateName;
                option.textContent = defaultTemplateName;
                select.appendChild(option);
            }
            
            // Dodaj resztƒô szablon√≥w, posortowanych alfabetycznie
            Object.keys(TEMPLATES)
                .filter(key => key !== defaultTemplateName) // Opr√≥cz "New Character"
                .sort() // Sortuj
                .forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = key;
                    select.appendChild(option);
                });
            
            select.value = defaultTemplateName; // Ustaw domy≈õlnie na "New Character"
        }
        
        /**
         * Tworzy nowƒÖ postaƒá na podstawie wybranego szablonu.
         */
        function applyTemplateToNewCharacter() {
            const select = document.getElementById('templateSelect');
            const templateName = select.value || 'New Character'; 
            
            const template = TEMPLATES[templateName];
            createNewCharacter(template); // Funkcja tworzƒÖca postaƒá
        }

        /**
         * Stosuje wybrany szablon do ISTNIEJƒÑCEJ postaci (po potwierdzeniu).
         * @param {number} index - Indeks postaci do nadpisania.
         */
        function applyTemplateConfirmation(index) {
            const select = document.getElementById('templateSelect');
            const templateName = select.value;

            if (templateName === "") {
                alert("Please select a template from the Global Controls section first.");
                return;
            }
            
            if (confirm(`Are you sure you want to apply the "${templateName}" template to this character? This will overwrite its attributes, vitality, trauma, and wounds.`)) {
                const template = TEMPLATES[templateName];
                
                // Lista atrybut√≥w do skopiowania z szablonu
                const attributesToApply = {
                    vitality: template.vitality,
                    perception: template.perception,
                    strength: template.strength,
                    dexterity: template.dexterity,
                    agility: template.agility,
                    armor: template.armor,
                    charisma: template.charisma,
                    potential: template.potential,
                    stability: template.stability,
                    reason: template.reason
                };

                let char = allCharacters[index];
                Object.assign(char, attributesToApply); // Nadpisanie atrybut√≥w postaci
                
                // Reset obra≈ºe≈Ñ, trybu edycji i koloru
                char.trauma = 0;
                char.wound = 0;
                char.editMode = 'locked'; 
                char.cardColorIndex = 0; // Reset koloru do domy≈õlnego

                saveAllCharacters();
                renderAllCharacters(); // Przerenderowanie sceny
            }
        }
        
        /**
         * Importuje szablony z pliku JSON.
         * Plik mo≈ºe byƒá plikiem zapisu sceny (tablica) lub pojedynczej postaci.
         * @param {Event} event - Zdarzenie 'onchange' z inputu pliku.
         */
        function importTemplates(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = e.target.result;
                    const parsedData = JSON.parse(data); 
                    
                    let importedTemplates = {};

                    // Logika parsowania (dla tablicy lub obiektu)
                    if (Array.isArray(parsedData)) {
                        // Plik zapisu sceny (wiele postaci)
                        parsedData.forEach(char => {
                            if (char.name && char.vitality) {
                                let templateName = char.name;
                                // Usu≈Ñ dane specyficzne dla instancji (obra≈ºenia, statusy)
                                delete char.trauma;
                                delete char.wound;
                                delete char.statusFire;
                                delete char.statusIce;
                                delete char.statusPoison;
                                importedTemplates[templateName] = char;
                            }
                        });
                    } else if (parsedData && typeof parsedData === 'object' && parsedData.name && parsedData.vitality) {
                        // Plik zapisu pojedynczej postaci
                        let char = parsedData;
                        let templateName = char.name;
                        delete char.trauma;
                        delete char.wound;
                        delete char.statusFire;
                        delete char.statusIce;
                        delete char.statusPoison;
                        importedTemplates[templateName] = char;
                    } else {
                        throw new Error('Invalid file format. Must be a "Save All" file or a single character file.');
                    }

                    Object.assign(TEMPLATES, importedTemplates); // Dodaj nowe szablony do globalnego obiektu
                    localStorage.setItem(VAGRANT_TEMPLATES_KEY, JSON.stringify(TEMPLATES)); // Zapisz w localStorage
                    populateTemplateSelect(); // Od≈õwie≈º listƒô
                    alert(`Templates imported successfully (${Object.keys(importedTemplates).length})!`);

                } catch (error) {
                    alert('Loading error: ' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Wyczy≈õƒá input pliku
        }
        
        /**
         * NOWA FUNKCJA: Usuwa wybrany szablon z listy (tylko szablony u≈ºytkownika).
         */
        function deleteSelectedTemplate() {
            const select = document.getElementById('templateSelect');
            const templateName = select.value;

            // Zabezpieczenie przed usuniƒôciem 'New Character'
            if (templateName === 'New Character') {
                alert("Cannot delete the default 'New Character' template.");
                return;
            }
            
            // Zabezpieczenie przed usuniƒôciem innych domy≈õlnych szablon√≥w
            if (DEFAULT_TEMPLATES.hasOwnProperty(templateName)) {
                 alert(`Cannot delete the default template: "${templateName}".`);
                 return;
            }

            // Je≈õli dotarli≈õmy tutaj, jest to szablon dodany przez u≈ºytkownika
            if (confirm(`Are you sure you want to delete the user template: "${templateName}"?`)) {
                let savedTemplates = JSON.parse(localStorage.getItem(VAGRANT_TEMPLATES_KEY)) || {};
                
                let deleted = false;
                // Usu≈Ñ z obiektu w pamiƒôci
                if (TEMPLATES.hasOwnProperty(templateName)) {
                    delete TEMPLATES[templateName]; 
                    deleted = true;
                }
                
                // Usu≈Ñ z obiektu w localStorage
                if (savedTemplates.hasOwnProperty(templateName)) {
                    delete savedTemplates[templateName]; 
                    localStorage.setItem(VAGRANT_TEMPLATES_KEY, JSON.stringify(savedTemplates)); // Zapisz zmiany
                    deleted = true;
                }
                
                if (deleted) {
                    populateTemplateSelect(); // Od≈õwie≈º listƒô
                    alert(`Template "${templateName}" deleted.`);
                } else {
                    alert(`Template "${templateName}" not found in user templates.`);
                }
            }
        }


        // --- FUNKCJE Z DOLNYCH PRZYCISK√ìW ---

        /**
         * Leczy Traumƒô i Rany wszystkim postaciom na scenie.
         */
        function healAll() {
            if (confirm('Heal all Trauma and Wounds for all characters?')) {
                allCharacters.forEach(char => {
                    char.trauma = 0;
                    char.wound = 0;
                });
                saveAllCharacters();
                renderAllCharacters(); // Przerenderuj, aby zaktualizowaƒá paski ≈ºycia
            }
        }

        /**
         * Usuwa WSZYSTKIE postacie ze sceny (po potwierdzeniu).
         */
        function clearAll() {
            if (confirm('WARNING: This will delete ALL characters. Are you sure?')) {
                allCharacters = []; // Wyczy≈õƒá tablicƒô postaci
                saveAllCharacters();
                renderAllCharacters(); // Przerenderuj (poka≈ºe pustƒÖ scenƒô)
            }
        }

        /**
         * Resetuje CA≈ÅƒÑ stronƒô - usuwa postacie i szablony z localStorage.
         */
        function resetPage() {
            if (confirm('WARNING: This will reset the entire page, deleting all characters AND imported templates. Are you sure?')) {
                localStorage.clear(); // Wyczy≈õƒá wszystko z localStorage
                location.reload(); // Prze≈Çaduj stronƒô
            }
        }

        /**
         * Pokazuje okienko informacyjne.
         */
        function showInfo() {
            alert('Vagrant RPS v1.0\nCreated by Genpiusz\n\nInfo panel coming soon.');
        }
        
        // --- RENDEROWANIE (RYSOWANIE) KART ---

        /**
         * Helper: Generuje HTML dla pojedynczego elementu atrybutu.
         * @param {object} char - Obiekt postaci.
         * @param {number} index - Indeks postaci.
         * @param {string} key - Klucz atrybutu (np. 'strength').
         * @param {string} label - Etykieta (np. 'STRENGTH').
         * @returns {string} - Kod HTML.
         */
        function renderAttributeItem(char, index, key, label) {
            const value = char[key] || 0;
            
            // Czy atrybut powinien mieƒá znak '+' (np. +1, +0, -1)
            const isSigned = (key !== 'vitality' && key !== 'armor');
            const sign = isSigned && value >= 0 ? '+' : '';
            
            // Klasa 'locked' lub '' w zale≈ºno≈õci od trybu edycji
            const initialModeClass = char.editMode === 'locked' ? 'locked' : '';

            // Czy na atrybut mo≈ºna rzucaƒá (wszystkie opr√≥cz VITALITY i ARMOR)
            const isRollable = (key !== 'vitality' && key !== 'armor');
            const rollOnClick = isRollable ? `rollDice(${index}, '${key}')` : '';
            const rollCursorClass = isRollable ? 'rollable' : '';
            
            return `
                <div class="attribute-item ${initialModeClass}">
                    <label title="${label} (${key})">${label}</label>
                    <span class="attribute-value ${rollCursorClass}" id="${key}ValueDisplay-${index}" onclick="${rollOnClick}">${sign}${value}</span>
                    <input type="number" 
                        id="${key}-${index}" 
                        value="${value}" 
                        oninput="updateAttribute(${index}, '${key}', this)"
                        onclick="selectContent(this)"> 
                </div>
            `;
        }

        /**
         * Generuje pe≈Çny kod HTML dla jednej karty postaci.
         * @param {object} char - Obiekt postaci.
         * @param {number} index - Indeks postaci.
         * @returns {string} - Kod HTML karty.
         */
        function renderCharacterCard(char, index) {
            // Klasy dla aktywnych status√≥w
            const statusFire = char.statusFire === 'on' ? 'active fire' : '';
            const statusIce = char.statusIce === 'on' ? 'active ice' : '';
            const statusPoison = char.statusPoison === 'on' ? 'active poison' : '';
            
            // Klasa i ikona dla trybu edycji
            const editModeClass = char.editMode === 'locked' ? 'locked' : '';
            const lockIcon = char.editMode === 'locked' ? 'üîí' : 'üîì';
            
            // Ustalenie koloru ramki karty na podstawie zapisanego indeksu
            const initialColorIndex = char.cardColorIndex !== undefined ? parseInt(char.cardColorIndex) : 0;
            const initialColor = CARD_COLORS[initialColorIndex] || CARD_COLORS[0];
            const cardStyle = `border: 4px solid ${initialColor}; box-shadow: 0 0 10px ${initialColor};`;

            // Wygenerowanie rzƒôd√≥w atrybut√≥w za pomocƒÖ funkcji renderAttributeItem
            const attributesRow1 = [
                { key: 'vitality', label: 'VITALITY' },
                { key: 'perception', label: 'PERCEPTION' },
                { key: 'strength', label: 'STRENGTH' },
                { key: 'dexterity', label: 'DEXTERITY' },
                { key: 'agility', label: 'AGILITY' }
            ].map(attr => renderAttributeItem(char, index, attr.key, attr.label)).join('');

            const attributesRow2 = [
                { key: 'armor', label: 'ARMOR' },
                { key: 'charisma', label: 'CHARISMA' },
                { key: 'potential', label: 'POTENTIAL' },
                { key: 'stability', label: 'STABILITY' },
                { key: 'reason', label: 'REASON' }
            ].map(attr => renderAttributeItem(char, index, attr.key, attr.label)).join('');
            
            // Zabezpieczenie nazwy (gdyby zawiera≈Ça cudzys≈Ç√≥w)
            const charName = char.name.replace(/"/g, '\\"'); 

            // Z≈Ço≈ºenie pe≈Çnego HTML karty
            return `
                <div class="card" data-index="${index}" style="${cardStyle}">
                    <div class="card-header">
                        <div class="card-buttons-left">
                            <button class="top-action-button" onclick="moveCharacter(${index}, -1)" title="Move Up">üîº</button>
                        </div>
                        
                        <div class="input-name ${editModeClass}" id="inputNameContainer-${index}" onclick="if (allCharacters[${index}].editMode === 'locked') toggleAttributeSection(${index})">
                            <input type="text" id="name-${index}" value="${char.name}" placeholder="Character Name" oninput="updateName(${index}, this)">
                            <span class="display-name" id="displayName-${index}">${char.name}</span>
                        </div>
                        
                        <div class="card-buttons-top">
                            <button class="top-action-button" onclick="moveCharacter(${index}, 1)" title="Move Down">üîΩ</button>
                        </div>
                    </div>

                    <div class="health-bar-display">
                        <div class="health-bar-container" id="healthBarContainer-${index}"> 
                            <span class="value-overlay current-vitality-display" id="currentVitalityDisplay-${index}"></span>
                            <div class="damage-bar trauma-wound-bar" id="traumaWoundBar-${index}" title="Trauma + Wound"></div>
                            <div class="damage-bar wound-bar" id="woundBar-${index}" title="Wound">
                                <span class="value-overlay wound-value-display" id="woundValueDisplay-${index}"></span>
                            </div>
                            <span class="value-overlay trauma-value-display" id="traumaValueDisplay-${index}"></span>
                        </div>
                    </div>
                    
                    <div class="control-row-main">
                        <button class="mod-button" onclick="changeValue(${index}, 'trauma', 1)" title="Increase Trauma">‚öï
						üíÄ</button>
                        <button class="mod-button" onclick="changeValue(${index}, 'trauma', -1)" title="Decrease Trauma">‚öï
						‚ûï</button>
                        |
                        <button class="status-button ${statusFire}" id="btn-fire-${index}" onclick="toggleStatus(${index}, 'fire')" title="Toggle Fire Status">üî•</button>
                        <button class="status-button ${statusIce}" id="btn-ice-${index}" onclick="toggleStatus(${index}, 'ice')" title="Toggle Ice Status">‚ùÑ</button>
                        <button class="status-button ${statusPoison}" id="btn-poison-${index}" onclick="toggleStatus(${index}, 'poison')" title="Toggle Poison Status">‚ò£</button>
                        |
                        <button class="mod-button" onclick="changeValue(${index}, 'wound', 1)" title="Take Wound">ü©∏
						üíß</button>
                        <button class="mod-button" onclick="changeValue(${index}, 'wound', -1)" title="Heal Wound">ü©∏
						‚ûï</button>
                    </div>

                    <div class="attribute-section" id="attributeSection-${index}">
                        <div class="attribute-row">${attributesRow1}</div>
                        <div class="attribute-row">${attributesRow2}</div>
                        
                        <div class="attribute-buttons">
                            <button class="top-action-button" onclick="exportSingleCharacter(${index})" title="Save Character to file">üíæ</button>
                            <button class="top-action-button" onclick="deleteCharacter(${index})" title="Delete Character">üóë</button>
                            <button class="top-action-button" onclick="applyTemplateConfirmation(${index})" title="Apply Template">‚ú®</button>
                            <button class="top-action-button" onclick="flatRoll(${index})" title="Flat Roll üé≤">üé≤</button>
                            <button class="top-action-button" onclick="toggleCardColor(${index})" title="Change Card Color">üé®</button>
                            <button class="top-action-button" id="editModeToggle-${index}" onclick="toggleEditMode(${index}, 'toggle')" title="Toggle Edit Lock">${lockIcon}</button>
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * G≈Ç√≥wna funkcja renderujƒÖca. Czy≈õci kontener i renderuje wszystkie postacie od nowa.
         */
        function renderAllCharacters() {
            const container = document.getElementById('characterContainer');
            
            // Zbudowanie ca≈Çego HTML dla wszystkich kart
            let allCardsHtml = '';
            allCharacters.forEach((char, index) => {
                allCardsHtml += renderCharacterCard(char, index);
            });
            // Wstawienie HTML do kontenera (szybsze ni≈º dodawanie po jednej karcie)
            container.innerHTML = allCardsHtml;

            // Po wyrenderowaniu, musimy zaktualizowaƒá paski ≈ºycia i tryby edycji
            allCharacters.forEach((char, index) => {
                setTimeout(() => updateHealthBar(index), 0); // Pasek ≈ºycia (w timeout, aby DOM zdƒÖ≈ºy≈Ç siƒô "uspokoiƒá")
                toggleEditMode(index, char.editMode); // Ustawienie trybu k≈Ç√≥dki
            });
            
            // Aktualizacja przycisku trybu rzutu w nag≈Ç√≥wku
            document.getElementById('rollModeToggleHeader').textContent = rollMode.replace('2d12', 'd12');
        }
        
        /**
         * Tworzy nowy obiekt postaci i dodaje go do tablicy allCharacters.
         * @param {object} [data={}] - Dane szablonu (opcjonalne).
         */
        function createNewCharacter(data = {}) {
            // Po≈ÇƒÖczenie domy≈õlnych atrybut√≥w z danymi szablonu
            const templateData = { ...DEFAULT_ATTRIBUTES, ...data };
            
            // Stworzenie obiektu nowej postaci
            const newChar = {
                name: templateData.name || 'New Character', 
                vitality: templateData.vitality !== undefined ? templateData.vitality : DEFAULT_VITALITY,
                trauma: 0, // Zawsze 0 na starcie
                wound: 0, // Zawsze 0 na starcie
                statusFire: templateData.statusFire || 'off',
                statusIce: templateData.statusIce || 'off',
                statusPoison: templateData.statusPoison || 'off',
                editMode: templateData.editMode || 'locked',
                
                cardColorIndex: 0, // Domy≈õlny kolor ramki
                
                // Kopiowanie atrybut√≥w
                perception: templateData.perception,
                strength: templateData.strength,
                dexterity: templateData.dexterity,
                agility: templateData.agility,
                armor: templateData.armor,
                charisma: templateData.charisma,
                potential: templateData.potential,
                stability: templateData.stability,
                reason: templateData.reason
            };
            allCharacters.push(newChar); // Dodanie do tablicy
            saveAllCharacters();
            renderAllCharacters();
        }

        /**
         * Usuwa postaƒá z tablicy (po potwierdzeniu).
         * @param {number} index - Indeks postaci do usuniƒôcia.
         */
        function deleteCharacter(index) {
            if (confirm(`Confirm deletion: ${allCharacters[index].name}?`)) {
                allCharacters.splice(index, 1); // Usuniƒôcie z tablicy
                saveAllCharacters();
                renderAllCharacters();
            }
        }
        
        // --- LOGIKA EKSPORTU / IMPORTU / ZAPISU ---

        /**
         * Zapisuje ca≈ÇƒÖ tablicƒô allCharacters do localStorage.
         */
        function saveAllCharacters() { 
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(allCharacters)); 
        }

        /**
         * Wczytuje postacie z localStorage przy ≈Çadowaniu strony.
         */
        function loadAllCharacters() {
            const data = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY));
            if (data && data.length > 0) {
                // Mapowanie danych dla kompatybilno≈õci wstecznej
                allCharacters = data.map(char => {
                    // Usuniƒôcie starych, nieu≈ºywanych kluczy (je≈õli istniejƒÖ)
                    const { nameShadowColorIndex, ...rest } = char;
                    
                    // Upewnienie siƒô, ≈ºe nowe klucze (jak cardColorIndex) istniejƒÖ
                    if (rest.cardColorIndex === undefined) {
                        rest.cardColorIndex = 0; // Domy≈õlny kolor
                    }
                    
                    return rest;
                });
            } else {
                allCharacters = []; // Pusta tablica, je≈õli nic nie ma w localStorage
            }
            renderAllCharacters(); // Renderowanie wczytanych postaci
        }

        /**
         * Eksportuje WSZYSTKIE postacie ze sceny do pliku .json.
         */
        function exportCharacters() { 
            // Eksport jako tablica (oczyszczona ze starych kluczy)
            const dataToExport = allCharacters.map(char => {
                const { nameShadowColorIndex, ...rest } = char;
                return rest;
            });
            
            // Formatowany JSON (null, 2) dla czytelno≈õci
            const data = JSON.stringify(dataToExport, null, 2); 
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); // Niewidzialny link
            a.href = url;
            a.download = 'allCharactersData.json'; // Nazwa pliku
            document.body.appendChild(a);
            a.click(); // Symulacja klikniƒôcia
            document.body.removeChild(a); // Usuniƒôcie linku
        }

        /**
         * Eksportuje JEDNƒÑ postaƒá do pliku .json.
         * @param {number} index - Indeks postaci do eksportu.
         */
        function exportSingleCharacter(index) {
            let char = allCharacters[index];
            if (!char) return;
            
            // Oczyszczenie obiektu
            const { nameShadowColorIndex, ...charToExport } = char;
            
            // ZAPIS JAKO TABLICA JEDNEGO ELEMENTU (dla kompatybilno≈õci z importAllCharacters)
            const data = JSON.stringify([charToExport], null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // Nazwa pliku na podstawie nazwy postaci
            const fileName = (char.name.replace(/[^a-z0-9]/gi, '_') || 'character') + '.json';
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        /**
         * Importuje postacie z pliku .json (scenƒô lub pojedynczƒÖ postaƒá).
         * @param {Event} event - Zdarzenie 'onchange' z inputu pliku.
         */
        function importAllCharacters(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = e.target.result;
                    const parsedData = JSON.parse(data); // Plik musi byƒá tablicƒÖ

                    if (!Array.isArray(parsedData) || parsedData.length === 0) { 
                         throw new Error('Invalid file format. Data must be an array of characters.'); 
                    }
                    
                    // Oczyszczenie importowanych danych (kompatybilno≈õƒá)
                    const cleanedData = parsedData.map(char => {
                        const { nameShadowColorIndex, ...rest } = char;
                        if (rest.cardColorIndex === undefined) {
                            rest.cardColorIndex = 0; 
                        }
                        return rest;
                    });
                    
                    let charactersToAdd = [];
                    let actionText = '';
                    
                    if (cleanedData.length === 1) {
                        // Je≈õli plik zawiera tylko 1 postaƒá
                        charactersToAdd = cleanedData;
                        actionText = `one character ("${cleanedData[0].name}") to the current scene`;
                    } else {
                        // Je≈õli plik zawiera scenƒô (wiele postaci)
                        charactersToAdd = cleanedData;
                        actionText = `${cleanedData.length} characters (replacing the current scene)`;
                    }

                    // Potwierdzenie od u≈ºytkownika
                    if (confirm(`Do you want to load the file? This will add ${actionText}.`)) {
                        if (cleanedData.length === 1) {
                            // DODANIE jednej postaci do istniejƒÖcej listy
                            allCharacters.push(charactersToAdd[0]);
                        } else {
                            // NADPISANIE sceny wieloma postaciami
                            allCharacters = charactersToAdd;
                        }
                        
                        saveAllCharacters();
                        renderAllCharacters();
                        alert(`Successfully loaded ${cleanedData.length} character(s)!`);
                    }
                } catch (error) { 
                    alert('Loading error: ' + error.message); 
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset inputu
        }


        // --- INICJALIZACJA STRONY ---
        
        // Wywo≈Çane po za≈Çadowaniu ca≈Çej strony
        window.onload = () => {
            loadAndMergeTemplates(); // Za≈Çaduj szablony (domy≈õlne + u≈ºytkownika)
            populateTemplateSelect(); // Wype≈Çnij listƒô rozwijanƒÖ
            loadAllCharacters(); // Wczytaj zapisane postacie
        };
    </script>
</body>
</html>




